{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Daptin\n\n\nDaptin is a backend designed to serve all your needs. Once you have deployed daptin, all you need to worry about is the frontend to get a complete app.\n\n\nIndex\n\n\n\n\nSetting up\n\n\nEntities\n\n\nEntity Relations\n\n\nData storage and table structures\n\n\nActions\n\n\nUsers and User groups\n\n\nAuthentication\n\n\nAuthorization\n\n\nAuditing\n\n\nState tracking for entities\n\n\nOauth Connections and tokens\n\n\nStorage connectors\n\n\nSub sites\n\n\nData streams\n\n\nJson schemas\n\n\nInteracting with third party APIs\n\n\nMarketplace", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-daptin", 
            "text": "Daptin is a backend designed to serve all your needs. Once you have deployed daptin, all you need to worry about is the frontend to get a complete app.", 
            "title": "Welcome to Daptin"
        }, 
        {
            "location": "/#index", 
            "text": "Setting up  Entities  Entity Relations  Data storage and table structures  Actions  Users and User groups  Authentication  Authorization  Auditing  State tracking for entities  Oauth Connections and tokens  Storage connectors  Sub sites  Data streams  Json schemas  Interacting with third party APIs  Marketplace", 
            "title": "Index"
        }, 
        {
            "location": "/settingup/", 
            "text": "Setting up Daptin\n\n\nYou can setup daptin on any machine/server of your choice.\n\n\nNative binary\n\n\nDaptin is available as a native binary for almost all systems. You can fetch the lastest binary from the releases\n\n\nhttps://github.com/daptin/daptin/releases\n\n\nDocker\n\n\nA docker image is also available which can be deployed on any docker compatible host\n\n\nhttps://hub.docker.com/r/daptin/daptin/\n\n\nTo start daptin using docker\n\n\ndocker run daptin/daptin\n\n\nData storage\n\n\nDaptin can use one of the following database for persistence\n\n\n\n\nMysql\n\n\nPostgres\n\n\nSQLite\n\n\n\n\nIf nothing specified, a sqlite database is created on the local file system and is used for all purposes. (uploads/blobs are not stored in database)\n\n\nYou can customise the database connection properties when starting daptin\n\n\nmysql\n\n\nTo use mysql, start daptin as follows\n\n\n./daptin -db_type=mysql -db_connection_string='\nusername\n:\npassword\n@tcp(\nhostname\n:\nport\n)/\ndb_name\n'\n\n\npostgres\n\n\n./daptin -db_type=postgres -db_connection_string='host=\nhostname\n port=\nport\n user=\nusername\n password=\npassword\n dbname=\ndb_name\n sslmode=enable/disable'\n\n\nsqlite\n\n\nBy default a \"daptin.db\" file is created to store data\n\n\n./daptin -db_type=sqlite -db_connection_string=db_file_name.db\n\n\nPort\n\n\nDaptin will listen on port 6336 by default. You can change it by using the following argument\n\n\n-port=8080\n\n\nRestart\n\n\nDaptin relies on self restarts to configure new entities and apis. As soon as you upload a schema file, daptin will write the file to disk, and restart itself. When it starts it will read the schema file, make appropriate changes to the database and expose JSON apis for the entities and actions.\n\n\nYou can issue a daptin restart from the dashboard. Daptin takes about 15 seconds approx to start up and configure everything.",
            "title": "Setting up"
        }, 
        {
            "location": "/settingup/#setting-up-daptin", 
            "text": "You can setup daptin on any machine/server of your choice.", 
            "title": "Setting up Daptin"
        }, 
        {
            "location": "/settingup/#native-binary", 
            "text": "Daptin is available as a native binary for almost all systems. You can fetch the lastest binary from the releases  https://github.com/daptin/daptin/releases",
            "title": "Native binary"
        }, 
        {
            "location": "/settingup/#docker", 
            "text": "A docker image is also available which can be deployed on any docker compatible host  https://hub.docker.com/r/daptin/daptin/  To start daptin using docker  docker run daptin/daptin", 
            "title": "Docker"
        }, 
        {
            "location": "/settingup/#data-storage", 
            "text": "Daptin can use one of the following database for persistence   Mysql  Postgres  SQLite   If nothing specified, a sqlite database is created on the local file system and is used for all purposes. (uploads/blobs are not stored in database)  You can customise the database connection properties when starting daptin", 
            "title": "Data storage"
        }, 
        {
            "location": "/settingup/#mysql", 
            "text": "To use mysql, start daptin as follows  ./daptin -db_type=mysql -db_connection_string=' username : password @tcp( hostname : port )/ db_name '", 
            "title": "mysql"
        }, 
        {
            "location": "/settingup/#postgres", 
            "text": "./daptin -db_type=postgres -db_connection_string='host= hostname  port= port  user= username  password= password  dbname= db_name  sslmode=enable/disable'", 
            "title": "postgres"
        }, 
        {
            "location": "/settingup/#sqlite", 
            "text": "By default a \"daptin.db\" file is created to store data  ./daptin -db_type=sqlite -db_connection_string=db_file_name.db", 
            "title": "sqlite"
        }, 
        {
            "location": "/settingup/#port", 
            "text": "Daptin will listen on port 6336 by default. You can change it by using the following argument  -port=8080", 
            "title": "Port"
        }, 
        {
            "location": "/settingup/#restart", 
            "text": "Daptin relies on self restarts to configure new entities and apis. As soon as you upload a schema file, daptin will write the file to disk, and restart itself. When it starts it will read the schema file, make appropriate changes to the database and expose JSON apis for the entities and actions.  You can issue a daptin restart from the dashboard. Daptin takes about 15 seconds approx to start up and configure everything.", 
            "title": "Restart"
        }, 
        {
            "location": "/entities/", 
            "text": "Entites\n\n\nEntities are the foundation for daptin. Everything else in daptin work on one or more entities. To define an entity, we specify the fields which belong to an entity and its relations with other entities. A collection of entities and their relations will be called a schema.\n\n\nLets imagine we were creating a todo application and wanted to track the follwing for each todo item\n- the todo text - lets call this \"title\"\n- a description - a longer text, which may or may not be empty\n- a deadline date - a date field to capture the deadline\n- completed - a true/false field, which captures if the todo is done\n- order - a field to store the priority of each todo\n\n\nAlong with the fields mentioned above, we might want certain validations and conformations whenever we store a new todo\n\n\n\n\ntitle cannot be empty\n\n\norder has to be numeric\n\n\n\n\nOnce we have come up with the above picture in mind, we can use one of the following ways to tell daptin about this:\n\n\nOnline entity designer\n\n\nThe entity designer is accessible from dashboard using the \"Online designer\" button. Here you can set the name, add columns and relations and create it.\n\n\n\n\nMarket place\n\n\nCheckout \nmarketplace documentation\n\n\nJSON / YAML files\n\n\nThe JSON for our hypothetical todo entity will look as follows:\n\n\n    {\n        \nTables\n: [{\n            \nTableName\n: \ntodo\n,\n            \nColumns\n: [{\n                    \nName\n: \ntitle\n,\n                    \nDataType\n: \nvarchar(500)\n,\n                    \nColumnType\n: \nlabel\n,\n                    \nIsIndexed\n: true\n                },\n                {\n                    \nName\n: \ncompleted\n,\n                    \nDataType\n: \nint(1)\n,\n                    \nColumnType\n: \ntruefalse\n,\n                    \nDefaultValue\n: \nfalse\n\n                },\n                {\n                    \nName\n: \ndeadline\n,\n                    \nDataType\n: \ndate\n,\n                    \nColumnType\n: \ndate\n,\n                    \nIsNullable\n: true\n                },\n                {\n                    \nName\n: \norder\n,\n                    \nColumnName\n: \nitem_order\n,\n                    \nDataType\n: \nint(4)\n,\n                    \nColumnType\n: \nmeasurement\n,\n                    \nDefaultValue\n: \n10\n\n                },\n                {\n                    \nName\n: \ntext\n,\n                    \nDataType\n: \ntext\n,\n                    \nColumnType\n: \ncontent\n,\n                    \nIsNullable\n: true\n                }\n            ],\n            \nConformations\n: [{\n                \nColumnName\n: \norder\n,\n                \nTags\n: \nnumeric\n\n            }],\n            \nvalidations\n: [{\n                \nColumnName\n: \ntitle\n,\n                \nTags\n: \nrequired\n\n            }]\n]}\n\n\n\n\nWhile the same description in YAML will look as follows\n\n\nTables:\n- TableName: todo\n  Columns:\n  - Name: title\n    DataType: varchar(500)\n    ColumnType: label\n    IsIndexed: true\n  - Name: url\n    DataType: varchar(200)\n    ColumnType: url\n    IsNullable: true\n  - Name: completed\n    DataType: int(1)\n    ColumnType: truefalse\n    DefaultValue: 'false'\n  - Name: schedule\n    DataType: date\n    ColumnType: date\n    IsNullable: true\n  - Name: order\n    ColumnName: item_order\n    DataType: int(4)\n    ColumnType: measurement\n    DefaultValue: '10'\n  - Name: text\n    DataType: text\n    ColumnType: content\n    IsNullable: true\n  Conformations:\n  - ColumnName: order\n    Tags: numeric\n  Validations:\n  - ColumnName: title\nTags: required\n\n\n\n\nYou can choose to work with either json or yaml. Once the schema is ready, it can be uploaded directly from daptin dashboard.\n\n\nColumn specifications\n\n\nColumns of the entity can be cusomised:\n\n\nName              string         `human readable name, can be skipped`\nColumnName        string         `column name in the table`\nColumnDescription string         `human readable description`\nColumnType        string         `column type is a rich type of the column`\nIsIndexed         boolean        `true to add an index on this column`\nIsUnique          boolean        `true to set a unique constraint on this column`\nIsNullable        boolean        `are null values allowed`\nPermission        uint64          `permission column (check authorization docs)`\nDataType          string         `the column type inside the database`\nDefaultValue      string         `default value if any (has to be inside single quotes for static values`\n\n\n\nColumn types\n\n\nDaptin supports a variety of rich data types, which helps it to automatically make intelligent decisions and validations. Here is a list of all column types and what should they be used for\n\n\n id:\n     an identity column, mostly for internal purposes\n alias:\n     a foreign key column\n date:\n     full date, no time\n time:\n     time/time interval, no date\n day:\n     day of the month - 1 to 31\n month:\n     month of the year - 1 to 12\n year:\n     Year\n minute:\n     minute of the hour - 0 to 59\n hour:\n     hour of the dat - 0 - 23\n datetime:\n     date + time (not stored as timestamp, served at date time string)\n email:\n     email\n name:\n     column to be used as name of the entity\n json:\n     JSON data\n password:\n     password - are bcrypted with cost 11\n value:\n     value is enumeration type\n truefalse:\n     boolean\n timestamp:\n     timestamp (stored as timestamp, served as timestamp)\n location.latitude:\n     only latitude\n location:\n     latitude + longitude in geoJson format\n location.longitude:\n     only longitude\n location.altitude:\n     only altitude\n color:\n     hex color string (#ABCDE1)\n rating.10:\n     rating on a scale of 10\n measurement:\n     numeric column\n label:\n     a label for the entity, similar to name but can be more than one\n content:\n     larger contents - texts/html/json/yaml\n file:\n     uploads, connect storage for using this\n url:\n     Urls/links\n\n\n\nValidations\n\n\nDaptin uses the excellent \ngo-playground/validator\n library to extensive validations\n\n\nIt has the following unique features:\n\n\n\n\nCross Field and Cross Struct validations by using validation tags or custom validators.\n\n\nSlice, Array and Map diving, which allows any or all levels of a multidimensional field to be validated.\n\n\n\n\nConformations\n\n\nDaptin uses the excellent \nleebenson/conform\n library to apply conformations on data before storing them in the database\n\n\n\n\nConform- keep user input in check (go, golang)\n\n\nTrim, sanitize, and modify struct string fields in place, based on tags.\n\n\n\n\nUse it for names, e-mail addresses, URL slugs, or any other form field where formatting matters.\n\n\nConform doesn't attempt any kind of validation on your fields.\n\n\nExcel file upload\n\n\nYou can upload data from XLS. Daptin will take care of going through your XLS file and identifying column types. This is one of the easiest and fastest ways to create entities and uploading data in daptin. You can specify relations among entities later from the online designer.\n\n\nRestart\n\n\nDaptin relies on self restarts to configure new entities and apis. As soon as you upload a schema file, daptin will write the file to disk, and restart itself. When it starts it will read the schema file, make appropriate changes to the database and expose JSON apis for the entities and actions.\n\n\nYou can issue a daptin restart from the dashboard. Daptin takes about 15 seconds approx to start up and configure everything.", 
            "title": "Entities"
        }, 
        {
            "location": "/entities/#entites", 
            "text": "Entities are the foundation for daptin. Everything else in daptin work on one or more entities. To define an entity, we specify the fields which belong to an entity and its relations with other entities. A collection of entities and their relations will be called a schema.  Lets imagine we were creating a todo application and wanted to track the follwing for each todo item\n- the todo text - lets call this \"title\"\n- a description - a longer text, which may or may not be empty\n- a deadline date - a date field to capture the deadline\n- completed - a true/false field, which captures if the todo is done\n- order - a field to store the priority of each todo  Along with the fields mentioned above, we might want certain validations and conformations whenever we store a new todo   title cannot be empty  order has to be numeric   Once we have come up with the above picture in mind, we can use one of the following ways to tell daptin about this:", 
            "title": "Entites"
        }, 
        {
            "location": "/entities/#online-entity-designer", 
            "text": "The entity designer is accessible from dashboard using the \"Online designer\" button. Here you can set the name, add columns and relations and create it.", 
            "title": "Online entity designer"
        }, 
        {
            "location": "/entities/#market-place", 
            "text": "Checkout  marketplace documentation", 
            "title": "Market place"
        }, 
        {
            "location": "/entities/#json-yaml-files", 
            "text": "The JSON for our hypothetical todo entity will look as follows:      {\n         Tables : [{\n             TableName :  todo ,\n             Columns : [{\n                     Name :  title ,\n                     DataType :  varchar(500) ,\n                     ColumnType :  label ,\n                     IsIndexed : true\n                },\n                {\n                     Name :  completed ,\n                     DataType :  int(1) ,\n                     ColumnType :  truefalse ,\n                     DefaultValue :  false \n                },\n                {\n                     Name :  deadline ,\n                     DataType :  date ,\n                     ColumnType :  date ,\n                     IsNullable : true\n                },\n                {\n                     Name :  order ,\n                     ColumnName :  item_order ,\n                     DataType :  int(4) ,\n                     ColumnType :  measurement ,\n                     DefaultValue :  10 \n                },\n                {\n                     Name :  text ,\n                     DataType :  text ,\n                     ColumnType :  content ,\n                     IsNullable : true\n                }\n            ],\n             Conformations : [{\n                 ColumnName :  order ,\n                 Tags :  numeric \n            }],\n             validations : [{\n                 ColumnName :  title ,\n                 Tags :  required \n            }]\n]}  While the same description in YAML will look as follows  Tables:\n- TableName: todo\n  Columns:\n  - Name: title\n    DataType: varchar(500)\n    ColumnType: label\n    IsIndexed: true\n  - Name: url\n    DataType: varchar(200)\n    ColumnType: url\n    IsNullable: true\n  - Name: completed\n    DataType: int(1)\n    ColumnType: truefalse\n    DefaultValue: 'false'\n  - Name: schedule\n    DataType: date\n    ColumnType: date\n    IsNullable: true\n  - Name: order\n    ColumnName: item_order\n    DataType: int(4)\n    ColumnType: measurement\n    DefaultValue: '10'\n  - Name: text\n    DataType: text\n    ColumnType: content\n    IsNullable: true\n  Conformations:\n  - ColumnName: order\n    Tags: numeric\n  Validations:\n  - ColumnName: title\nTags: required  You can choose to work with either json or yaml. Once the schema is ready, it can be uploaded directly from daptin dashboard.", 
            "title": "JSON / YAML files"
        }, 
        {
            "location": "/entities/#column-specifications", 
            "text": "Columns of the entity can be cusomised:  Name              string         `human readable name, can be skipped`\nColumnName        string         `column name in the table`\nColumnDescription string         `human readable description`\nColumnType        string         `column type is a rich type of the column`\nIsIndexed         boolean        `true to add an index on this column`\nIsUnique          boolean        `true to set a unique constraint on this column`\nIsNullable        boolean        `are null values allowed`\nPermission        uint64          `permission column (check authorization docs)`\nDataType          string         `the column type inside the database`\nDefaultValue      string         `default value if any (has to be inside single quotes for static values`", 
            "title": "Column specifications"
        }, 
        {
            "location": "/entities/#column-types", 
            "text": "Daptin supports a variety of rich data types, which helps it to automatically make intelligent decisions and validations. Here is a list of all column types and what should they be used for   id:\n     an identity column, mostly for internal purposes\n alias:\n     a foreign key column\n date:\n     full date, no time\n time:\n     time/time interval, no date\n day:\n     day of the month - 1 to 31\n month:\n     month of the year - 1 to 12\n year:\n     Year\n minute:\n     minute of the hour - 0 to 59\n hour:\n     hour of the dat - 0 - 23\n datetime:\n     date + time (not stored as timestamp, served at date time string)\n email:\n     email\n name:\n     column to be used as name of the entity\n json:\n     JSON data\n password:\n     password - are bcrypted with cost 11\n value:\n     value is enumeration type\n truefalse:\n     boolean\n timestamp:\n     timestamp (stored as timestamp, served as timestamp)\n location.latitude:\n     only latitude\n location:\n     latitude + longitude in geoJson format\n location.longitude:\n     only longitude\n location.altitude:\n     only altitude\n color:\n     hex color string (#ABCDE1)\n rating.10:\n     rating on a scale of 10\n measurement:\n     numeric column\n label:\n     a label for the entity, similar to name but can be more than one\n content:\n     larger contents - texts/html/json/yaml\n file:\n     uploads, connect storage for using this\n url:\n     Urls/links", 
            "title": "Column types"
        }, 
        {
            "location": "/entities/#validations", 
            "text": "Daptin uses the excellent  go-playground/validator  library to extensive validations  It has the following unique features:   Cross Field and Cross Struct validations by using validation tags or custom validators.  Slice, Array and Map diving, which allows any or all levels of a multidimensional field to be validated.", 
            "title": "Validations"
        }, 
        {
            "location": "/entities/#conformations", 
            "text": "Daptin uses the excellent  leebenson/conform  library to apply conformations on data before storing them in the database   Conform- keep user input in check (go, golang)  Trim, sanitize, and modify struct string fields in place, based on tags.   Use it for names, e-mail addresses, URL slugs, or any other form field where formatting matters.  Conform doesn't attempt any kind of validation on your fields.", 
            "title": "Conformations"
        }, 
        {
            "location": "/entities/#excel-file-upload", 
            "text": "You can upload data from XLS. Daptin will take care of going through your XLS file and identifying column types. This is one of the easiest and fastest ways to create entities and uploading data in daptin. You can specify relations among entities later from the online designer.", 
            "title": "Excel file upload"
        }, 
        {
            "location": "/entities/#restart", 
            "text": "Daptin relies on self restarts to configure new entities and apis. As soon as you upload a schema file, daptin will write the file to disk, and restart itself. When it starts it will read the schema file, make appropriate changes to the database and expose JSON apis for the entities and actions.  You can issue a daptin restart from the dashboard. Daptin takes about 15 seconds approx to start up and configure everything.", 
            "title": "Restart"
        }, 
        {
            "location": "/entity_relations/", 
            "text": "Entity relations\n\n\nA data oriented system with no relational knowledge of the data is next to an Excel sheet. Specifying relations in your data is the most important thing after creating your entities.\n\n\nSpecfying relations using JSON/YAML upload\n\n\nWhen uploading schema using a JSON / YAML file, relations can be added in the same file and daptin will create appropriate constraints and foreign keys in your underlying database.\n\n\nContinuing with our example of todos, lets say we want to group todo's in \"projects\" and each todo can belong to only a single project.\n\n\nLets design a \"project\" entity:\n\n\n- TableName: project\n  Columns:\n  - Name: name\n    DataType: varchar(200)\n    ColumnType: name\n    IsIndexed: true\n\n\n\n\nA very simple table with just a name column. Now we can tell daptin about the relation between todos and projects\n\n\nRelations:\n- Subject: todo\n  Relation: has_one\n  Object: project\n\n\n\n\nThis tells daptin that todo \"has_one\" project.\n\n\nRelations types\n\n\nAny entity can be associated to any other entity (or to itself) as one of the follows\n\n\n\n\nbelongs_to - a non-nullable relation, single object\n\n\nhas_one - a nullable relation, single object\n\n\nhas_many - a nullable realtion, many objects\n\n\n\n\nBasic relations for every entity\n\n\nEvery entity created on daptin has atleast two relations\n\n\n\n\nbelongs to \"user\"\n\n\nhas many \"usergroup\"\n\n\n\n\nTo understand why these two relations will always exist, checkout \ndaptin authorization model\n\n\nMore than 1 relation between two entities\n\n\nThere can definitely be a scenario where two entities are related in more then 1 way. Consider the following example\n\n\n\n\nA blog entity\n\n\nA post entity\n\n\nBlog as many posts (blog has many posts)\n\n\nEach blog as a \"highlighted post\" (blog has one \"highlighted post\"\n\n\n\n\nTo achieve the above scenario, our schema would look like as follows\n\n\nTables:\n- TableName: blog\n  Columns:\n  - Name: title\n    DataType: varchar(500)\n    ColumnType: label\n  - Name: view_count\n    DataType: int(11)\n    ColumnType: measurement\n- TableName: post\n  Columns:\n  - Name: title\n    DataType: varchar(200)\n    ColumnType: label\n  - Name: body\n    DataType: text\n    ColumnType: content\n- TableName: comment\n  Columns:\n  - Name: body\n    DataType: text\n    ColumnType: content\n  - Name: likes_count\n    ColumnName: likes_count\n    DataType: int(11)\n    ColumnType: measurement\nRelations:\n- Subject: comment\n  Relation: belongs_to\n  Object: post\n- Subject: post\n  Relation: belongs_to\n  Object: blog                   // this is our post belongs to blog relation\n- Subject: blog\n  Relation: has_one\n  Object: post\n  ObjectName: current_post\n  SubjectName: current_post_of   // this is our highlighted post relation\n\n\n\n\nNotice the \"SubjectName\" and \"ObjectName\" keys which helps to name our relations more intuitively.\n\n\nDatabase table structure behind the scene\n\n\nbelongs to\n\n\n\n\nA column is added to the subject entity, which refers to the Object entity, set to non nullable\n\n\n\n\nhas one\n\n\n\n\nSame as above, but nullable\n\n\n\n\nhas many\n\n\n\n\nA join table is created", 
            "title": "Entity Relations"
        }, 
        {
            "location": "/entity_relations/#entity-relations", 
            "text": "A data oriented system with no relational knowledge of the data is next to an Excel sheet. Specifying relations in your data is the most important thing after creating your entities.", 
            "title": "Entity relations"
        }, 
        {
            "location": "/entity_relations/#specfying-relations-using-jsonyaml-upload", 
            "text": "When uploading schema using a JSON / YAML file, relations can be added in the same file and daptin will create appropriate constraints and foreign keys in your underlying database.  Continuing with our example of todos, lets say we want to group todo's in \"projects\" and each todo can belong to only a single project.  Lets design a \"project\" entity:  - TableName: project\n  Columns:\n  - Name: name\n    DataType: varchar(200)\n    ColumnType: name\n    IsIndexed: true  A very simple table with just a name column. Now we can tell daptin about the relation between todos and projects  Relations:\n- Subject: todo\n  Relation: has_one\n  Object: project  This tells daptin that todo \"has_one\" project.", 
            "title": "Specfying relations using JSON/YAML upload"
        }, 
        {
            "location": "/entity_relations/#relations-types", 
            "text": "Any entity can be associated to any other entity (or to itself) as one of the follows   belongs_to - a non-nullable relation, single object  has_one - a nullable relation, single object  has_many - a nullable realtion, many objects", 
            "title": "Relations types"
        }, 
        {
            "location": "/entity_relations/#basic-relations-for-every-entity", 
            "text": "Every entity created on daptin has atleast two relations   belongs to \"user\"  has many \"usergroup\"   To understand why these two relations will always exist, checkout  daptin authorization model", 
            "title": "Basic relations for every entity"
        }, 
        {
            "location": "/entity_relations/#more-than-1-relation-between-two-entities", 
            "text": "There can definitely be a scenario where two entities are related in more then 1 way. Consider the following example   A blog entity  A post entity  Blog as many posts (blog has many posts)  Each blog as a \"highlighted post\" (blog has one \"highlighted post\"   To achieve the above scenario, our schema would look like as follows  Tables:\n- TableName: blog\n  Columns:\n  - Name: title\n    DataType: varchar(500)\n    ColumnType: label\n  - Name: view_count\n    DataType: int(11)\n    ColumnType: measurement\n- TableName: post\n  Columns:\n  - Name: title\n    DataType: varchar(200)\n    ColumnType: label\n  - Name: body\n    DataType: text\n    ColumnType: content\n- TableName: comment\n  Columns:\n  - Name: body\n    DataType: text\n    ColumnType: content\n  - Name: likes_count\n    ColumnName: likes_count\n    DataType: int(11)\n    ColumnType: measurement\nRelations:\n- Subject: comment\n  Relation: belongs_to\n  Object: post\n- Subject: post\n  Relation: belongs_to\n  Object: blog                   // this is our post belongs to blog relation\n- Subject: blog\n  Relation: has_one\n  Object: post\n  ObjectName: current_post\n  SubjectName: current_post_of   // this is our highlighted post relation  Notice the \"SubjectName\" and \"ObjectName\" keys which helps to name our relations more intuitively.", 
            "title": "More than 1 relation between two entities"
        }, 
        {
            "location": "/entity_relations/#database-table-structure-behind-the-scene", 
            "text": "", 
            "title": "Database table structure behind the scene"
        }, 
        {
            "location": "/entity_relations/#belongs-to", 
            "text": "A column is added to the subject entity, which refers to the Object entity, set to non nullable", 
            "title": "belongs to"
        }, 
        {
            "location": "/entity_relations/#has-one", 
            "text": "Same as above, but nullable", 
            "title": "has one"
        }, 
        {
            "location": "/entity_relations/#has-many", 
            "text": "A join table is created", 
            "title": "has many"
        }, 
        {
            "location": "/users_and_usergroups/", 
            "text": "Users\n\n\nUsers are native objects in Daptin. Every item in daptin belongs to one user. A user which is not identified is a guest user.\n\n\nA user belongs to one or more user groups.\n\n\nUser groups\n\n\nUser groups is a really powerful concept that helps you manage \"who\" can interact with daptin, and in what ways.\n\n\nObjects can also belong to one or more user group.", 
            "title": "Users and groups"
        }, 
        {
            "location": "/users_and_usergroups/#users", 
            "text": "Users are native objects in Daptin. Every item in daptin belongs to one user. A user which is not identified is a guest user.  A user belongs to one or more user groups.", 
            "title": "Users"
        }, 
        {
            "location": "/users_and_usergroups/#user-groups", 
            "text": "User groups is a really powerful concept that helps you manage \"who\" can interact with daptin, and in what ways.  Objects can also belong to one or more user group.", 
            "title": "User groups"
        }, 
        {
            "location": "/authorization/", 
            "text": "Access Authorization\n\n\nThere are three type of interactions which we want to control\n\n\n\n\nRead access\n\n\nWrite access - this includes creating/updating/deleting\n\n\nActions - this includes actions which can be performed on the objects\n\n\n\n\nAccess flow\n\n\nEvery \"intercation\" in daptin goes through two levels of access\n\n\n\n\nEntity level access: does the user invoking the interaction has the appropriate permission to invoke this (So for sign up, the user table need to be writable by guests, for sign in the user table needs to be readable by guests)\n\n\nInstance level access: this is the second level, even if a user has access to \"user\" entity, not all \"user\" rows would be accessible by them\n\n\n\n\nEntity level permission\n\n\nEntity level permission are set in the world table and can be updated from dashboard. This can be done by updating the \"permission\" column for the entity.\n\n\nFor these changes to take effect a restart is necessary.\n\n\nInstance level permission\n\n\nLike we saw in the \nentity documentation\n, every table has a \npermission\n column.\n\n\nPermission column\n\n\nThe permission column contains a three digit number, which decides the access for guests, user groups and owner\n\n\nPermission model is completely based on linux file system permission. No need to worry if you are not aware of that. Here is a brief overview\n\n\nThe three digits can be represented as follows:\n\n\nU G W\n\n\nU = User\nG = Group\nW = World\n\n\n4 = Readable\n2 = Writable\n1 = Execute action\n0 = No permission\n\n\nHere is another way of looking at it:\n\n\nPermissions:\n\n\n400 read by owner\n040 read by group\n004 read by anybody (other)\n200 write by owner\n020 write by group\n002 write by anybody\n100 execute by owner\n010 execute by group\n001 execute by anybody\n\n\nTo get a combination, just add them up.\n\n\nFor example, to get\n\n\n\n\nread, write, execute by owner\n\n\nread, execute, by group\n\n\nexecute by anybody\n\n\n\n\nyou would add 400+200+100+040+010+001 to give 751.", 
            "title": "Authorization"
        }, 
        {
            "location": "/authorization/#access-authorization", 
            "text": "There are three type of interactions which we want to control   Read access  Write access - this includes creating/updating/deleting  Actions - this includes actions which can be performed on the objects", 
            "title": "Access Authorization"
        }, 
        {
            "location": "/authorization/#access-flow", 
            "text": "Every \"intercation\" in daptin goes through two levels of access   Entity level access: does the user invoking the interaction has the appropriate permission to invoke this (So for sign up, the user table need to be writable by guests, for sign in the user table needs to be readable by guests)  Instance level access: this is the second level, even if a user has access to \"user\" entity, not all \"user\" rows would be accessible by them", 
            "title": "Access flow"
        }, 
        {
            "location": "/authorization/#entity-level-permission", 
            "text": "Entity level permission are set in the world table and can be updated from dashboard. This can be done by updating the \"permission\" column for the entity.  For these changes to take effect a restart is necessary.", 
            "title": "Entity level permission"
        }, 
        {
            "location": "/authorization/#instance-level-permission", 
            "text": "Like we saw in the  entity documentation , every table has a  permission  column.", 
            "title": "Instance level permission"
        }, 
        {
            "location": "/authorization/#permission-column", 
            "text": "The permission column contains a three digit number, which decides the access for guests, user groups and owner  Permission model is completely based on linux file system permission. No need to worry if you are not aware of that. Here is a brief overview  The three digits can be represented as follows:  U G W  U = User\nG = Group\nW = World  4 = Readable\n2 = Writable\n1 = Execute action\n0 = No permission  Here is another way of looking at it:  Permissions:  400 read by owner\n040 read by group\n004 read by anybody (other)\n200 write by owner\n020 write by group\n002 write by anybody\n100 execute by owner\n010 execute by group\n001 execute by anybody  To get a combination, just add them up.  For example, to get   read, write, execute by owner  read, execute, by group  execute by anybody   you would add 400+200+100+040+010+001 to give 751.", 
            "title": "Permission column"
        }, 
        {
            "location": "/actions/", 
            "text": "Actions\n\n\nActions are the most useful things in Daptin and we will see that everything you have done in Daptin was as action itself.\n\n\nActions can be thought of as follows:\n\n\n\n\nA set of inputs\n\n\nA set of outcomes based on the inputs\n\n\n\n\nWhat are actions and why do I need this\n\n\nCreate/Read/Update/Delete (CRUD) APIs are only the most basic apis exposed on the database, and you would rarely want to make those API available to your end user. Reasons could be multiple\n\n\n\n\nThe end user doesn't (immediately) owe the data they create\n\n\nCreating a \"row\"/\"data entry\" entry doesnt signify completion of a process or a flow\n\n\nUsually a \"set of entities\" is to created and not just a single entity (when you create a user, you also want to create a usergroup also and associate the user to usergroup)\n\n\nYou could allow user to update only some fields of an entity and not all fields (eg user can change their name, but not email)\n\n\nChanges based on some entity (when you are going though a project, a new todo should automatically belong to that project)\n\n\n\n\nActions provide a powerful abstraction over the CRUD and handle all of these use cases.\n\n\nTo quickly understand what actions are, lets see what happened when you \"signed up\" on Daptin.\n\n\nLets take a look at how \"Sign up\" action is defined in Daptin. We will go through each part of this definition\n\n\nAction schema\n\n\n    {\n        Name:             \nsignup\n,\n        Label:            \nSign up\n,\n        InstanceOptional: true,\n        OnType:           \nuser\n,\n        InFields: []api2go.ColumnInfo{\n            {\n                Name:       \nname\n,\n                ColumnName: \nname\n,\n                ColumnType: \nlabel\n,\n                IsNullable: false,\n            },\n            {\n                Name:       \nemail\n,\n                ColumnName: \nemail\n,\n                ColumnType: \nemail\n,\n                IsNullable: false,\n            },\n            {\n                Name:       \npassword\n,\n                ColumnName: \npassword\n,\n                ColumnType: \npassword\n,\n                IsNullable: false,\n            },\n            {\n                Name:       \nPassword Confirm\n,\n                ColumnName: \npasswordConfirm\n,\n                ColumnType: \npassword\n,\n                IsNullable: false,\n            },\n        },\n        Validations: []ColumnTag{\n            {\n                ColumnName: \nemail\n,\n                Tags:       \nemail\n,\n            },\n            {\n                ColumnName: \nname\n,\n                Tags:       \nrequired\n,\n            },\n            {\n                ColumnName: \npassword\n,\n                Tags:       \neqfield=InnerStructField[passwordConfirm],min=8\n,\n            },\n        },\n        Conformations: []ColumnTag{\n            {\n                ColumnName: \nemail\n,\n                Tags:       \nemail\n,\n            },\n            {\n                ColumnName: \nname\n,\n                Tags:       \ntrim\n,\n            },\n        },\n        OutFields: []Outcome{\n            {\n                Type:      \nuser\n,\n                Method:    \nPOST\n,\n                Reference: \nuser\n,\n                Attributes: map[string]interface{}{\n                    \nname\n:      \n~name\n,\n                    \nemail\n:     \n~email\n,\n                    \npassword\n:  \n~password\n,\n                    \nconfirmed\n: \n0\n,\n                },\n            },\n            {\n                Type:      \nusergroup\n,\n                Method:    \nPOST\n,\n                Reference: \nusergroup\n,\n                Attributes: map[string]interface{}{\n                    \nname\n: \n!'Home group for ' + user.name\n,\n                },\n            },\n            {\n                Type:      \nuser_user_id_has_usergroup_usergroup_id\n,\n                Method:    \nPOST\n,\n                Reference: \nuser_usergroup\n,\n                Attributes: map[string]interface{}{\n                    \nuser_id\n:      \n$user.reference_id\n,\n                    \nusergroup_id\n: \n$usergroup.reference_id\n,\n                },\n            },\n            {\n                Type:   \nclient.notify\n,\n                Method: \nACTIONRESPONSE\n,\n                Attributes: map[string]interface{}{\n                    \ntype\n:    \nsuccess\n,\n                    \ntitle\n:   \nSuccess\n,\n                    \nmessage\n: \nSignup Successful\n,\n                },\n            },\n            {\n                Type:   \nclient.redirect\n,\n                Method: \nACTIONRESPONSE\n,\n                Attributes: map[string]interface{}{\n                    \nlocation\n: \n/auth/signin\n,\n                    \nwindow\n:   \nself\n,\n                },\n            },\n        },\n    }\n\n\n\n\nAction Name\n\n\n    Name:             \"signup\",\n\n\n\nName of the action, this should be unique for each actions. Actions are identified by this name\n\n\nAction Label\n\n\n    Label:            \"Sign up\",\n\n\n\nLabel is humans\n\n\nOnType\n\n\n    OnType:           \"user\",\n\n\n\nThe primary type of entity on which the action happens. This is used to know where the actions should come up on the UI\n\n\nAction instance\n\n\n    InstanceOptional: true,\n\n\n\nIf the action requires an \"instance\" of that type on which the action is defined (more about this below). So \"Sign up\" is defined on \"user\" table, but an instance of \"user\" is not required to initiate the action. This is why the \"Sign up\" doesnt ask you to select a user (which wouldn't make sense either)\n\n\nInput fields\n\n\n    InFields: []api2go.ColumnInfo\n\n\n\nThis is a set of inputs which the user need to fill in to initiate that action. As we see here in case of \"Sign up\", we ask for four inputs\n\n\n\n\nName\n\n\nEmail\n\n\nPassword\n\n\nConfirm password\n\n\n\n\nNote that the ColumnInfo structure is the same one we used to \ndefine tables\n.\n\n\nValidations\n\n\n    Validations: []ColumnTag\n\n\n\nValidations validate the user input and rejects if some validation fails\n\n\n        {\n            ColumnName: \"email\",\n            Tags:       \"email\",\n        },\n\n\n\nThis tells that the \"email\" input should actually be an email.\n\n\nOne of the more interesting validations is cross field check\n\n\n        {\n            ColumnName: \"password\",\n            Tags:       \"eqfield=InnerStructField[passwordConfirm],min=8\",\n        },\n\n\n\nThis tells that the value entered by user in the password field should be equal to the value in passwordConfirm field. And the minimum length should be 8 characters.\n\n\nConformations\n\n\n    Conformations: []ColumnTag\n\n\n\nConformations help to clean the data before the action is carried out. The frequently one used are \ntrim\n and \nemail\n.\n\n\n\n\nTrim: trim removes white spaces, which are sometimes accidently introduced when entering data\n\n\nEmail: email conformation will normalize the email. Things like lowercase + trim\n\n\n\n\nOutFields\n\n\n    OutFields: []Outcome\n\n\n\nOutFields are the list of outcomes which the action will result in. The outcomes are evaluated in a top to bottom manner, and the result of one outcome is accessible when evaluating the next outcome.\n\n\nWe have defined three outcomes in our \"Sign Up\" action.\n\n\n\n\nCreate a user\n    {\n        Type:      \"user\",\n        Method:    \"POST\",\n        Reference: \"user\",\n        Attributes: map[string]interface{}{\n            \"name\":      \"~name\",\n            \"email\":     \"~email\",\n            \"password\":  \"~password\",\n            \"confirmed\": \"0\",\n        },\n    },\n\n\n\n\n\n\n\nThis tells us that, the first outcome is of type \"user\". The outcome is a \"New User\" (POST). It could alternatively have been a Update/Find/Delete operation.\n\n\nThe attributes maps the input fields to the fields of our new user.\n\n\n\n\n~name\n will be the value entered by user in the name field\n\n\n~email\n will be the entered in the email field, and so on\n\n\n\n\nIf we skip the \n~\n, like \n\"confirmed\": \"0\"\n Then the literal value is used.\n\n\nReference: \"user\",\n We have this to allow the \"outcome\" to be referenced when evaluating the next outcome. Let us see the other outcomes\n\n\nScripted fields - \"!...\"\n\n\n        {\n            Type:      \"usergroup\",\n            Method:    \"POST\",\n            Reference: \"usergroup\",\n            Attributes: map[string]interface{}{\n                \"name\": \"!'Home group for ' + user.name\",\n            },\n        },\n\n\n\nDaptin includes the \notto js engine\n. An exclamation mark tell daptin to evaluate the rest of the string as Javascript.\n\n\n'Home group for ' + user.name\n becomes \"Home group for parth\"\n\n\nReferencing previous outcomes\n\n\n        {\n            Type:      \"user_user_id_has_usergroup_usergroup_id\",\n            Method:    \"POST\",\n            Reference: \"user_usergroup\",\n            Attributes: map[string]interface{}{\n                \"user_id\":      \"$user.reference_id\",\n                \"usergroup_id\": \"$usergroup.reference_id\",\n            },\n        },\n\n\n\nthe \n$\n sign is to refer the previous outcomes. Here this outcome adds the newly created user to the newly created usergroup.", 
            "title": "Actions"
        }, 
        {
            "location": "/actions/#actions", 
            "text": "Actions are the most useful things in Daptin and we will see that everything you have done in Daptin was as action itself.  Actions can be thought of as follows:   A set of inputs  A set of outcomes based on the inputs", 
            "title": "Actions"
        }, 
        {
            "location": "/actions/#what-are-actions-and-why-do-i-need-this", 
            "text": "Create/Read/Update/Delete (CRUD) APIs are only the most basic apis exposed on the database, and you would rarely want to make those API available to your end user. Reasons could be multiple   The end user doesn't (immediately) owe the data they create  Creating a \"row\"/\"data entry\" entry doesnt signify completion of a process or a flow  Usually a \"set of entities\" is to created and not just a single entity (when you create a user, you also want to create a usergroup also and associate the user to usergroup)  You could allow user to update only some fields of an entity and not all fields (eg user can change their name, but not email)  Changes based on some entity (when you are going though a project, a new todo should automatically belong to that project)   Actions provide a powerful abstraction over the CRUD and handle all of these use cases.  To quickly understand what actions are, lets see what happened when you \"signed up\" on Daptin.  Lets take a look at how \"Sign up\" action is defined in Daptin. We will go through each part of this definition", 
            "title": "What are actions and why do I need this"
        }, 
        {
            "location": "/actions/#action-schema", 
            "text": "{\n        Name:              signup ,\n        Label:             Sign up ,\n        InstanceOptional: true,\n        OnType:            user ,\n        InFields: []api2go.ColumnInfo{\n            {\n                Name:        name ,\n                ColumnName:  name ,\n                ColumnType:  label ,\n                IsNullable: false,\n            },\n            {\n                Name:        email ,\n                ColumnName:  email ,\n                ColumnType:  email ,\n                IsNullable: false,\n            },\n            {\n                Name:        password ,\n                ColumnName:  password ,\n                ColumnType:  password ,\n                IsNullable: false,\n            },\n            {\n                Name:        Password Confirm ,\n                ColumnName:  passwordConfirm ,\n                ColumnType:  password ,\n                IsNullable: false,\n            },\n        },\n        Validations: []ColumnTag{\n            {\n                ColumnName:  email ,\n                Tags:        email ,\n            },\n            {\n                ColumnName:  name ,\n                Tags:        required ,\n            },\n            {\n                ColumnName:  password ,\n                Tags:        eqfield=InnerStructField[passwordConfirm],min=8 ,\n            },\n        },\n        Conformations: []ColumnTag{\n            {\n                ColumnName:  email ,\n                Tags:        email ,\n            },\n            {\n                ColumnName:  name ,\n                Tags:        trim ,\n            },\n        },\n        OutFields: []Outcome{\n            {\n                Type:       user ,\n                Method:     POST ,\n                Reference:  user ,\n                Attributes: map[string]interface{}{\n                     name :       ~name ,\n                     email :      ~email ,\n                     password :   ~password ,\n                     confirmed :  0 ,\n                },\n            },\n            {\n                Type:       usergroup ,\n                Method:     POST ,\n                Reference:  usergroup ,\n                Attributes: map[string]interface{}{\n                     name :  !'Home group for ' + user.name ,\n                },\n            },\n            {\n                Type:       user_user_id_has_usergroup_usergroup_id ,\n                Method:     POST ,\n                Reference:  user_usergroup ,\n                Attributes: map[string]interface{}{\n                     user_id :       $user.reference_id ,\n                     usergroup_id :  $usergroup.reference_id ,\n                },\n            },\n            {\n                Type:    client.notify ,\n                Method:  ACTIONRESPONSE ,\n                Attributes: map[string]interface{}{\n                     type :     success ,\n                     title :    Success ,\n                     message :  Signup Successful ,\n                },\n            },\n            {\n                Type:    client.redirect ,\n                Method:  ACTIONRESPONSE ,\n                Attributes: map[string]interface{}{\n                     location :  /auth/signin ,\n                     window :    self ,\n                },\n            },\n        },\n    }", 
            "title": "Action schema"
        }, 
        {
            "location": "/actions/#action-name", 
            "text": "Name:             \"signup\",  Name of the action, this should be unique for each actions. Actions are identified by this name", 
            "title": "Action Name"
        }, 
        {
            "location": "/actions/#action-label", 
            "text": "Label:            \"Sign up\",  Label is humans", 
            "title": "Action Label"
        }, 
        {
            "location": "/actions/#ontype", 
            "text": "OnType:           \"user\",  The primary type of entity on which the action happens. This is used to know where the actions should come up on the UI", 
            "title": "OnType"
        }, 
        {
            "location": "/actions/#action-instance", 
            "text": "InstanceOptional: true,  If the action requires an \"instance\" of that type on which the action is defined (more about this below). So \"Sign up\" is defined on \"user\" table, but an instance of \"user\" is not required to initiate the action. This is why the \"Sign up\" doesnt ask you to select a user (which wouldn't make sense either)", 
            "title": "Action instance"
        }, 
        {
            "location": "/actions/#input-fields", 
            "text": "InFields: []api2go.ColumnInfo  This is a set of inputs which the user need to fill in to initiate that action. As we see here in case of \"Sign up\", we ask for four inputs   Name  Email  Password  Confirm password   Note that the ColumnInfo structure is the same one we used to  define tables .", 
            "title": "Input fields"
        }, 
        {
            "location": "/actions/#validations", 
            "text": "Validations: []ColumnTag  Validations validate the user input and rejects if some validation fails          {\n            ColumnName: \"email\",\n            Tags:       \"email\",\n        },  This tells that the \"email\" input should actually be an email.  One of the more interesting validations is cross field check          {\n            ColumnName: \"password\",\n            Tags:       \"eqfield=InnerStructField[passwordConfirm],min=8\",\n        },  This tells that the value entered by user in the password field should be equal to the value in passwordConfirm field. And the minimum length should be 8 characters.", 
            "title": "Validations"
        }, 
        {
            "location": "/actions/#conformations", 
            "text": "Conformations: []ColumnTag  Conformations help to clean the data before the action is carried out. The frequently one used are  trim  and  email .   Trim: trim removes white spaces, which are sometimes accidently introduced when entering data  Email: email conformation will normalize the email. Things like lowercase + trim", 
            "title": "Conformations"
        }, 
        {
            "location": "/actions/#outfields", 
            "text": "OutFields: []Outcome  OutFields are the list of outcomes which the action will result in. The outcomes are evaluated in a top to bottom manner, and the result of one outcome is accessible when evaluating the next outcome.  We have defined three outcomes in our \"Sign Up\" action.   Create a user     {\n        Type:      \"user\",\n        Method:    \"POST\",\n        Reference: \"user\",\n        Attributes: map[string]interface{}{\n            \"name\":      \"~name\",\n            \"email\":     \"~email\",\n            \"password\":  \"~password\",\n            \"confirmed\": \"0\",\n        },\n    },    This tells us that, the first outcome is of type \"user\". The outcome is a \"New User\" (POST). It could alternatively have been a Update/Find/Delete operation.  The attributes maps the input fields to the fields of our new user.   ~name  will be the value entered by user in the name field  ~email  will be the entered in the email field, and so on   If we skip the  ~ , like  \"confirmed\": \"0\"  Then the literal value is used.  Reference: \"user\",  We have this to allow the \"outcome\" to be referenced when evaluating the next outcome. Let us see the other outcomes", 
            "title": "OutFields"
        }, 
        {
            "location": "/actions/#scripted-fields-", 
            "text": "{\n            Type:      \"usergroup\",\n            Method:    \"POST\",\n            Reference: \"usergroup\",\n            Attributes: map[string]interface{}{\n                \"name\": \"!'Home group for ' + user.name\",\n            },\n        },  Daptin includes the  otto js engine . An exclamation mark tell daptin to evaluate the rest of the string as Javascript.  'Home group for ' + user.name  becomes \"Home group for parth\"", 
            "title": "Scripted fields - \"!...\""
        }, 
        {
            "location": "/actions/#referencing-previous-outcomes", 
            "text": "{\n            Type:      \"user_user_id_has_usergroup_usergroup_id\",\n            Method:    \"POST\",\n            Reference: \"user_usergroup\",\n            Attributes: map[string]interface{}{\n                \"user_id\":      \"$user.reference_id\",\n                \"usergroup_id\": \"$usergroup.reference_id\",\n            },\n        },  the  $  sign is to refer the previous outcomes. Here this outcome adds the newly created user to the newly created usergroup.", 
            "title": "Referencing previous outcomes"
        }, 
        {
            "location": "/data_storage/", 
            "text": "Data storage\n\n\nDaptin relies on a Relational Database for all data persistence requirements. As covered in the \nsetting up guide\n currently the following relational database are supported:\n\n\n\n\nMySQL\n\n\nPostgreSQL\n\n\nSQLite\n\n\n\n\nThis document goes into the detail of how the database is used and what are the tables created.\n\n\nStandard columns\n\n\nThe following 5 columns are present in every table\n\n\n\n\n\n\n\n\nColumnName\n\n\nColumnType\n\n\nDataType\n\n\nAttributes\n\n\n\n\n\n\n\n\n\n\nid\n\n\nid\n\n\nint64\n\n\nprimary key  Auto increment Never exposed externally\n\n\n\n\n\n\nversion\n\n\ninteger\n\n\nint64\n\n\nget incremented every time a change is made\n\n\n\n\n\n\ncreated_at\n\n\ntimestamp\n\n\ntimestamp\n\n\nthe timestamp when the row was created\n\n\n\n\n\n\nupdated_at\n\n\ntimestamp\n\n\ntimestamp\n\n\nthe timestamp when the row was last updated\n\n\n\n\n\n\nreference_id\n\n\nalias\n\n\nvarchar(40)\n\n\nThe id exposed in APIs\n\n\n\n\n\n\npermission\n\n\ninteger\n\n\nint(4)\n\n\nPermissions - check Authorization documentation\n\n\n\n\n\n\nuser_id\n\n\nforeign key\n\n\nint64\n\n\nthe owner of this object\n\n\n\n\n\n\n\n\nWorld table\n\n\nThe \nworld\n table holds the structure for all the entities and relations (including for itself).\n\n\nEach row contains the schema for the table in a \"world_schema_json\" column.", 
            "title": "Data storage"
        }, 
        {
            "location": "/data_storage/#data-storage", 
            "text": "Daptin relies on a Relational Database for all data persistence requirements. As covered in the  setting up guide  currently the following relational database are supported:   MySQL  PostgreSQL  SQLite   This document goes into the detail of how the database is used and what are the tables created.", 
            "title": "Data storage"
        }, 
        {
            "location": "/data_storage/#standard-columns", 
            "text": "The following 5 columns are present in every table     ColumnName  ColumnType  DataType  Attributes      id  id  int64  primary key  Auto increment Never exposed externally    version  integer  int64  get incremented every time a change is made    created_at  timestamp  timestamp  the timestamp when the row was created    updated_at  timestamp  timestamp  the timestamp when the row was last updated    reference_id  alias  varchar(40)  The id exposed in APIs    permission  integer  int(4)  Permissions - check Authorization documentation    user_id  foreign key  int64  the owner of this object", 
            "title": "Standard columns"
        }, 
        {
            "location": "/data_storage/#world-table", 
            "text": "The  world  table holds the structure for all the entities and relations (including for itself).  Each row contains the schema for the table in a \"world_schema_json\" column.", 
            "title": "World table"
        }, 
        {
            "location": "/marketplace/", 
            "text": "Marketplace\n\n\nDocumentation not ready yet", 
            "title": "Marketplace"
        }, 
        {
            "location": "/marketplace/#marketplace", 
            "text": "Documentation not ready yet", 
            "title": "Marketplace"
        }
    ]
}